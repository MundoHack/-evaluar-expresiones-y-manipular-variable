Grammar:

Rule 0     S' -> program
Rule 1     program -> decl_list
Rule 2     decl_list -> decl
Rule 3     decl_list -> decl_list decl
Rule 4     decl -> continue_stmt
Rule 5     decl -> func_decl
Rule 6     decl -> var_decl
Rule 7     var_decl -> type_spec IDENT [ ] ;
Rule 8     var_decl -> type_spec IDENT ;
Rule 9     type_spec -> FLOAT
Rule 10    type_spec -> INT
Rule 11    type_spec -> BOOL
Rule 12    type_spec -> VOID
Rule 13    func_decl -> type_spec IDENT ( params ) compound_stmt
Rule 14    params -> VOID
Rule 15    params -> param_list
Rule 16    param_list -> param
Rule 17    param_list -> param_list , param
Rule 18    param -> type_spec IDENT [ ]
Rule 19    param -> type_spec IDENT
Rule 20    compound_stmt -> { local_decls stmt_list }
Rule 21    local_decls -> empty
Rule 22    local_decls -> decl_list
Rule 23    stmt_list -> stmt
Rule 24    stmt_list -> stmt_list stmt
Rule 25    stmt -> continue_stmt
Rule 26    stmt -> break_stmt
Rule 27    stmt -> return_stmt
Rule 28    stmt -> while_stmt
Rule 29    stmt -> if_stmt
Rule 30    stmt -> compound_stmt
Rule 31    stmt -> expr_stmt
Rule 32    expr_stmt -> ;
Rule 33    expr_stmt -> expr ;
Rule 34    while_stmt -> WHILE ( expr ) stmt
Rule 35    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=right, level=2]
Rule 36    if_stmt -> IF ( expr ) stmt  [precedence=nonassoc, level=1]
Rule 37    return_stmt -> RETURN expr ;
Rule 38    return_stmt -> RETURN ;
Rule 39    break_stmt -> BREAK ;
Rule 40    continue_stmt -> CONTINUE ;
Rule 41    expr -> NEW type_spec [ expr ]
Rule 42    expr -> STRING_LIT
Rule 43    expr -> FLOAT_LIT
Rule 44    expr -> INT_LIT
Rule 45    expr -> BOOL_LIT
Rule 46    expr -> IDENT . SIZE
Rule 47    expr -> IDENT ( args )
Rule 48    expr -> IDENT [ expr ]
Rule 49    expr -> IDENT
Rule 50    expr -> ( expr )
Rule 51    expr -> + expr  [precedence=right, level=10]
Rule 52    expr -> - expr  [precedence=right, level=10]
Rule 53    expr -> ! expr  [precedence=right, level=10]
Rule 54    expr -> expr % expr  [precedence=left, level=9]
Rule 55    expr -> expr / expr  [precedence=left, level=9]
Rule 56    expr -> expr * expr  [precedence=left, level=9]
Rule 57    expr -> expr - expr  [precedence=left, level=8]
Rule 58    expr -> expr + expr  [precedence=left, level=8]
Rule 59    expr -> expr > expr  [precedence=left, level=7]
Rule 60    expr -> expr GE expr  [precedence=left, level=7]
Rule 61    expr -> expr < expr  [precedence=left, level=7]
Rule 62    expr -> expr LE expr  [precedence=left, level=7]
Rule 63    expr -> expr NE expr  [precedence=left, level=6]
Rule 64    expr -> expr EQ expr  [precedence=left, level=6]
Rule 65    expr -> expr AND expr  [precedence=left, level=5]
Rule 66    expr -> expr OR expr  [precedence=left, level=4]
Rule 67    expr -> IDENT [ expr ] = expr  [precedence=right, level=3]
Rule 68    expr -> IDENT = expr  [precedence=right, level=3]
Rule 69    args -> arg_list
Rule 70    arg_list -> expr
Rule 71    arg_list -> arg_list , expr
Rule 72    empty -> <empty>

Terminals, with rules where they appear:

!                    : 53
%                    : 54
(                    : 13 34 35 36 47 50
)                    : 13 34 35 36 47 50
*                    : 56
+                    : 51 58
,                    : 17 71
-                    : 52 57
.                    : 46
/                    : 55
;                    : 7 8 32 33 37 38 39 40
<                    : 61
=                    : 67 68
>                    : 59
AND                  : 65
BOOL                 : 11
BOOL_LIT             : 45
BREAK                : 39
CONTINUE             : 40
ELSE                 : 35
EQ                   : 64
FLOAT                : 9
FLOAT_LIT            : 43
GE                   : 60
IDENT                : 7 8 13 18 19 46 47 48 49 67 68
IF                   : 35 36
INT                  : 10
INT_LIT              : 44
LE                   : 62
NE                   : 63
NEW                  : 41
OR                   : 66
RETURN               : 37 38
SIZE                 : 46
STRING_LIT           : 42
VOID                 : 12 14
WHILE                : 34
[                    : 7 18 41 48 67
]                    : 7 18 41 48 67
error                : 
{                    : 20
}                    : 20

Nonterminals, with rules where they appear:

arg_list             : 69 71
args                 : 47
break_stmt           : 26
compound_stmt        : 13 30
continue_stmt        : 4 25
decl                 : 2 3
decl_list            : 1 3 22
empty                : 21
expr                 : 33 34 35 36 37 41 48 50 51 52 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 70 71
expr_stmt            : 31
func_decl            : 5
if_stmt              : 29
local_decls          : 20
param                : 16 17
param_list           : 15 17
params               : 13
program              : 0
return_stmt          : 27
stmt                 : 23 24 34 35 35 36
stmt_list            : 20 24
type_spec            : 7 8 13 18 19 41
var_decl             : 6
while_stmt           : 28


state 0

    (0) S' -> . program
    (1) program -> . decl_list
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . continue_stmt
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (40) continue_stmt -> . CONTINUE ;
    (13) func_decl -> . type_spec IDENT ( params ) compound_stmt
    (7) var_decl -> . type_spec IDENT [ ] ;
    (8) var_decl -> . type_spec IDENT ;
    (9) type_spec -> . FLOAT
    (10) type_spec -> . INT
    (11) type_spec -> . BOOL
    (12) type_spec -> . VOID
    CONTINUE        shift and go to state 7
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3
    continue_stmt                  shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 1

    (0) S' -> program .


state 2

    (1) program -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . continue_stmt
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (40) continue_stmt -> . CONTINUE ;
    (13) func_decl -> . type_spec IDENT ( params ) compound_stmt
    (7) var_decl -> . type_spec IDENT [ ] ;
    (8) var_decl -> . type_spec IDENT ;
    (9) type_spec -> . FLOAT
    (10) type_spec -> . INT
    (11) type_spec -> . BOOL
    (12) type_spec -> . VOID
    $end            reduce using rule 1 (program -> decl_list .)
    CONTINUE        shift and go to state 7
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    decl                           shift and go to state 13
    continue_stmt                  shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 3

    (2) decl_list -> decl .
    CONTINUE        reduce using rule 2 (decl_list -> decl .)
    FLOAT           reduce using rule 2 (decl_list -> decl .)
    INT             reduce using rule 2 (decl_list -> decl .)
    BOOL            reduce using rule 2 (decl_list -> decl .)
    VOID            reduce using rule 2 (decl_list -> decl .)
    $end            reduce using rule 2 (decl_list -> decl .)
    BREAK           reduce using rule 2 (decl_list -> decl .)
    RETURN          reduce using rule 2 (decl_list -> decl .)
    WHILE           reduce using rule 2 (decl_list -> decl .)
    IF              reduce using rule 2 (decl_list -> decl .)
    {               reduce using rule 2 (decl_list -> decl .)
    ;               reduce using rule 2 (decl_list -> decl .)
    NEW             reduce using rule 2 (decl_list -> decl .)
    STRING_LIT      reduce using rule 2 (decl_list -> decl .)
    FLOAT_LIT       reduce using rule 2 (decl_list -> decl .)
    INT_LIT         reduce using rule 2 (decl_list -> decl .)
    BOOL_LIT        reduce using rule 2 (decl_list -> decl .)
    IDENT           reduce using rule 2 (decl_list -> decl .)
    (               reduce using rule 2 (decl_list -> decl .)
    +               reduce using rule 2 (decl_list -> decl .)
    -               reduce using rule 2 (decl_list -> decl .)
    !               reduce using rule 2 (decl_list -> decl .)


state 4

    (4) decl -> continue_stmt .
    CONTINUE        reduce using rule 4 (decl -> continue_stmt .)
    FLOAT           reduce using rule 4 (decl -> continue_stmt .)
    INT             reduce using rule 4 (decl -> continue_stmt .)
    BOOL            reduce using rule 4 (decl -> continue_stmt .)
    VOID            reduce using rule 4 (decl -> continue_stmt .)
    $end            reduce using rule 4 (decl -> continue_stmt .)
    BREAK           reduce using rule 4 (decl -> continue_stmt .)
    RETURN          reduce using rule 4 (decl -> continue_stmt .)
    WHILE           reduce using rule 4 (decl -> continue_stmt .)
    IF              reduce using rule 4 (decl -> continue_stmt .)
    {               reduce using rule 4 (decl -> continue_stmt .)
    ;               reduce using rule 4 (decl -> continue_stmt .)
    NEW             reduce using rule 4 (decl -> continue_stmt .)
    STRING_LIT      reduce using rule 4 (decl -> continue_stmt .)
    FLOAT_LIT       reduce using rule 4 (decl -> continue_stmt .)
    INT_LIT         reduce using rule 4 (decl -> continue_stmt .)
    BOOL_LIT        reduce using rule 4 (decl -> continue_stmt .)
    IDENT           reduce using rule 4 (decl -> continue_stmt .)
    (               reduce using rule 4 (decl -> continue_stmt .)
    +               reduce using rule 4 (decl -> continue_stmt .)
    -               reduce using rule 4 (decl -> continue_stmt .)
    !               reduce using rule 4 (decl -> continue_stmt .)


state 5

    (5) decl -> func_decl .
    CONTINUE        reduce using rule 5 (decl -> func_decl .)
    FLOAT           reduce using rule 5 (decl -> func_decl .)
    INT             reduce using rule 5 (decl -> func_decl .)
    BOOL            reduce using rule 5 (decl -> func_decl .)
    VOID            reduce using rule 5 (decl -> func_decl .)
    $end            reduce using rule 5 (decl -> func_decl .)
    BREAK           reduce using rule 5 (decl -> func_decl .)
    RETURN          reduce using rule 5 (decl -> func_decl .)
    WHILE           reduce using rule 5 (decl -> func_decl .)
    IF              reduce using rule 5 (decl -> func_decl .)
    {               reduce using rule 5 (decl -> func_decl .)
    ;               reduce using rule 5 (decl -> func_decl .)
    NEW             reduce using rule 5 (decl -> func_decl .)
    STRING_LIT      reduce using rule 5 (decl -> func_decl .)
    FLOAT_LIT       reduce using rule 5 (decl -> func_decl .)
    INT_LIT         reduce using rule 5 (decl -> func_decl .)
    BOOL_LIT        reduce using rule 5 (decl -> func_decl .)
    IDENT           reduce using rule 5 (decl -> func_decl .)
    (               reduce using rule 5 (decl -> func_decl .)
    +               reduce using rule 5 (decl -> func_decl .)
    -               reduce using rule 5 (decl -> func_decl .)
    !               reduce using rule 5 (decl -> func_decl .)


state 6

    (6) decl -> var_decl .
    CONTINUE        reduce using rule 6 (decl -> var_decl .)
    FLOAT           reduce using rule 6 (decl -> var_decl .)
    INT             reduce using rule 6 (decl -> var_decl .)
    BOOL            reduce using rule 6 (decl -> var_decl .)
    VOID            reduce using rule 6 (decl -> var_decl .)
    $end            reduce using rule 6 (decl -> var_decl .)
    BREAK           reduce using rule 6 (decl -> var_decl .)
    RETURN          reduce using rule 6 (decl -> var_decl .)
    WHILE           reduce using rule 6 (decl -> var_decl .)
    IF              reduce using rule 6 (decl -> var_decl .)
    {               reduce using rule 6 (decl -> var_decl .)
    ;               reduce using rule 6 (decl -> var_decl .)
    NEW             reduce using rule 6 (decl -> var_decl .)
    STRING_LIT      reduce using rule 6 (decl -> var_decl .)
    FLOAT_LIT       reduce using rule 6 (decl -> var_decl .)
    INT_LIT         reduce using rule 6 (decl -> var_decl .)
    BOOL_LIT        reduce using rule 6 (decl -> var_decl .)
    IDENT           reduce using rule 6 (decl -> var_decl .)
    (               reduce using rule 6 (decl -> var_decl .)
    +               reduce using rule 6 (decl -> var_decl .)
    -               reduce using rule 6 (decl -> var_decl .)
    !               reduce using rule 6 (decl -> var_decl .)


state 7

    (40) continue_stmt -> CONTINUE . ;
    ;               shift and go to state 14


state 8

    (13) func_decl -> type_spec . IDENT ( params ) compound_stmt
    (7) var_decl -> type_spec . IDENT [ ] ;
    (8) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 15


state 9

    (9) type_spec -> FLOAT .
    IDENT           reduce using rule 9 (type_spec -> FLOAT .)
    [               reduce using rule 9 (type_spec -> FLOAT .)


state 10

    (10) type_spec -> INT .
    IDENT           reduce using rule 10 (type_spec -> INT .)
    [               reduce using rule 10 (type_spec -> INT .)


state 11

    (11) type_spec -> BOOL .
    IDENT           reduce using rule 11 (type_spec -> BOOL .)
    [               reduce using rule 11 (type_spec -> BOOL .)


state 12

    (12) type_spec -> VOID .
    IDENT           reduce using rule 12 (type_spec -> VOID .)
    [               reduce using rule 12 (type_spec -> VOID .)


state 13

    (3) decl_list -> decl_list decl .
    CONTINUE        reduce using rule 3 (decl_list -> decl_list decl .)
    FLOAT           reduce using rule 3 (decl_list -> decl_list decl .)
    INT             reduce using rule 3 (decl_list -> decl_list decl .)
    BOOL            reduce using rule 3 (decl_list -> decl_list decl .)
    VOID            reduce using rule 3 (decl_list -> decl_list decl .)
    $end            reduce using rule 3 (decl_list -> decl_list decl .)
    BREAK           reduce using rule 3 (decl_list -> decl_list decl .)
    RETURN          reduce using rule 3 (decl_list -> decl_list decl .)
    WHILE           reduce using rule 3 (decl_list -> decl_list decl .)
    IF              reduce using rule 3 (decl_list -> decl_list decl .)
    {               reduce using rule 3 (decl_list -> decl_list decl .)
    ;               reduce using rule 3 (decl_list -> decl_list decl .)
    NEW             reduce using rule 3 (decl_list -> decl_list decl .)
    STRING_LIT      reduce using rule 3 (decl_list -> decl_list decl .)
    FLOAT_LIT       reduce using rule 3 (decl_list -> decl_list decl .)
    INT_LIT         reduce using rule 3 (decl_list -> decl_list decl .)
    BOOL_LIT        reduce using rule 3 (decl_list -> decl_list decl .)
    IDENT           reduce using rule 3 (decl_list -> decl_list decl .)
    (               reduce using rule 3 (decl_list -> decl_list decl .)
    +               reduce using rule 3 (decl_list -> decl_list decl .)
    -               reduce using rule 3 (decl_list -> decl_list decl .)
    !               reduce using rule 3 (decl_list -> decl_list decl .)


state 14

    (40) continue_stmt -> CONTINUE ; .
    CONTINUE        reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    FLOAT           reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    INT             reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    BOOL            reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    VOID            reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    $end            reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    IF              reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    {               reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    ;               reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    NEW             reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    STRING_LIT      reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    FLOAT_LIT       reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    INT_LIT         reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    BOOL_LIT        reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    IDENT           reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    (               reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    +               reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    -               reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    !               reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    }               reduce using rule 40 (continue_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 40 (continue_stmt -> CONTINUE ; .)


state 15

    (13) func_decl -> type_spec IDENT . ( params ) compound_stmt
    (7) var_decl -> type_spec IDENT . [ ] ;
    (8) var_decl -> type_spec IDENT . ;
    (               shift and go to state 16
    [               shift and go to state 17
    ;               shift and go to state 18


state 16

    (13) func_decl -> type_spec IDENT ( . params ) compound_stmt
    (14) params -> . VOID
    (15) params -> . param_list
    (16) param_list -> . param
    (17) param_list -> . param_list , param
    (18) param -> . type_spec IDENT [ ]
    (19) param -> . type_spec IDENT
    (9) type_spec -> . FLOAT
    (10) type_spec -> . INT
    (11) type_spec -> . BOOL
    (12) type_spec -> . VOID
    VOID            shift and go to state 21
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11

    type_spec                      shift and go to state 19
    params                         shift and go to state 20
    param_list                     shift and go to state 22
    param                          shift and go to state 23

state 17

    (7) var_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 24


state 18

    (8) var_decl -> type_spec IDENT ; .
    CONTINUE        reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    INT             reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    $end            reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    BREAK           reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    RETURN          reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    WHILE           reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    IF              reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    {               reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    ;               reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    NEW             reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    STRING_LIT      reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    FLOAT_LIT       reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    INT_LIT         reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    BOOL_LIT        reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    IDENT           reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    (               reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    +               reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    -               reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    !               reduce using rule 8 (var_decl -> type_spec IDENT ; .)


state 19

    (18) param -> type_spec . IDENT [ ]
    (19) param -> type_spec . IDENT
    IDENT           shift and go to state 25


state 20

    (13) func_decl -> type_spec IDENT ( params . ) compound_stmt
    )               shift and go to state 26


state 21

    (14) params -> VOID .
    (12) type_spec -> VOID .
    )               reduce using rule 14 (params -> VOID .)
    IDENT           reduce using rule 12 (type_spec -> VOID .)


state 22

    (15) params -> param_list .
    (17) param_list -> param_list . , param
    )               reduce using rule 15 (params -> param_list .)
    ,               shift and go to state 27


state 23

    (16) param_list -> param .
    ,               reduce using rule 16 (param_list -> param .)
    )               reduce using rule 16 (param_list -> param .)


state 24

    (7) var_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 28


state 25

    (18) param -> type_spec IDENT . [ ]
    (19) param -> type_spec IDENT .
    [               shift and go to state 29
    ,               reduce using rule 19 (param -> type_spec IDENT .)
    )               reduce using rule 19 (param -> type_spec IDENT .)


state 26

    (13) func_decl -> type_spec IDENT ( params ) . compound_stmt
    (20) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 31

    compound_stmt                  shift and go to state 30

state 27

    (17) param_list -> param_list , . param
    (18) param -> . type_spec IDENT [ ]
    (19) param -> . type_spec IDENT
    (9) type_spec -> . FLOAT
    (10) type_spec -> . INT
    (11) type_spec -> . BOOL
    (12) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    param                          shift and go to state 32
    type_spec                      shift and go to state 19

state 28

    (7) var_decl -> type_spec IDENT [ ] ; .
    CONTINUE        reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    FLOAT           reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    $end            reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    BREAK           reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    RETURN          reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    WHILE           reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    IF              reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    {               reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    ;               reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    NEW             reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    STRING_LIT      reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    FLOAT_LIT       reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    INT_LIT         reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    BOOL_LIT        reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    IDENT           reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    (               reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    +               reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    -               reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)
    !               reduce using rule 7 (var_decl -> type_spec IDENT [ ] ; .)


state 29

    (18) param -> type_spec IDENT [ . ]
    ]               shift and go to state 33


state 30

    (13) func_decl -> type_spec IDENT ( params ) compound_stmt .
    CONTINUE        reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    FLOAT           reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    INT             reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    BOOL            reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    VOID            reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    $end            reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    BREAK           reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    RETURN          reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    WHILE           reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    IF              reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    {               reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    ;               reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    NEW             reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    STRING_LIT      reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    FLOAT_LIT       reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    INT_LIT         reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    BOOL_LIT        reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    IDENT           reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    (               reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    +               reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    -               reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)
    !               reduce using rule 13 (func_decl -> type_spec IDENT ( params ) compound_stmt .)


state 31

    (20) compound_stmt -> { . local_decls stmt_list }
    (21) local_decls -> . empty
    (22) local_decls -> . decl_list
    (72) empty -> .
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . continue_stmt
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (40) continue_stmt -> . CONTINUE ;
    (13) func_decl -> . type_spec IDENT ( params ) compound_stmt
    (7) var_decl -> . type_spec IDENT [ ] ;
    (8) var_decl -> . type_spec IDENT ;
    (9) type_spec -> . FLOAT
    (10) type_spec -> . INT
    (11) type_spec -> . BOOL
    (12) type_spec -> . VOID
  ! shift/reduce conflict for CONTINUE resolved as shift
    BREAK           reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    {               reduce using rule 72 (empty -> .)
    ;               reduce using rule 72 (empty -> .)
    NEW             reduce using rule 72 (empty -> .)
    STRING_LIT      reduce using rule 72 (empty -> .)
    FLOAT_LIT       reduce using rule 72 (empty -> .)
    INT_LIT         reduce using rule 72 (empty -> .)
    BOOL_LIT        reduce using rule 72 (empty -> .)
    IDENT           reduce using rule 72 (empty -> .)
    (               reduce using rule 72 (empty -> .)
    +               reduce using rule 72 (empty -> .)
    -               reduce using rule 72 (empty -> .)
    !               reduce using rule 72 (empty -> .)
    CONTINUE        shift and go to state 7
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    local_decls                    shift and go to state 34
    empty                          shift and go to state 35
    decl_list                      shift and go to state 36
    decl                           shift and go to state 3
    continue_stmt                  shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 32

    (17) param_list -> param_list , param .
    ,               reduce using rule 17 (param_list -> param_list , param .)
    )               reduce using rule 17 (param_list -> param_list , param .)


state 33

    (18) param -> type_spec IDENT [ ] .
    ,               reduce using rule 18 (param -> type_spec IDENT [ ] .)
    )               reduce using rule 18 (param -> type_spec IDENT [ ] .)


state 34

    (20) compound_stmt -> { local_decls . stmt_list }
    (23) stmt_list -> . stmt
    (24) stmt_list -> . stmt_list stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . return_stmt
    (28) stmt -> . while_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (40) continue_stmt -> . CONTINUE ;
    (39) break_stmt -> . BREAK ;
    (37) return_stmt -> . RETURN expr ;
    (38) return_stmt -> . RETURN ;
    (34) while_stmt -> . WHILE ( expr ) stmt
    (35) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt
    (20) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . ;
    (33) expr_stmt -> . expr ;
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    CONTINUE        shift and go to state 7
    BREAK           shift and go to state 47
    RETURN          shift and go to state 48
    WHILE           shift and go to state 50
    IF              shift and go to state 52
    {               shift and go to state 31
    ;               shift and go to state 46
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    stmt_list                      shift and go to state 37
    stmt                           shift and go to state 38
    continue_stmt                  shift and go to state 39
    break_stmt                     shift and go to state 40
    return_stmt                    shift and go to state 41
    while_stmt                     shift and go to state 42
    if_stmt                        shift and go to state 43
    compound_stmt                  shift and go to state 44
    expr_stmt                      shift and go to state 45
    expr                           shift and go to state 49

state 35

    (21) local_decls -> empty .
    CONTINUE        reduce using rule 21 (local_decls -> empty .)
    BREAK           reduce using rule 21 (local_decls -> empty .)
    RETURN          reduce using rule 21 (local_decls -> empty .)
    WHILE           reduce using rule 21 (local_decls -> empty .)
    IF              reduce using rule 21 (local_decls -> empty .)
    {               reduce using rule 21 (local_decls -> empty .)
    ;               reduce using rule 21 (local_decls -> empty .)
    NEW             reduce using rule 21 (local_decls -> empty .)
    STRING_LIT      reduce using rule 21 (local_decls -> empty .)
    FLOAT_LIT       reduce using rule 21 (local_decls -> empty .)
    INT_LIT         reduce using rule 21 (local_decls -> empty .)
    BOOL_LIT        reduce using rule 21 (local_decls -> empty .)
    IDENT           reduce using rule 21 (local_decls -> empty .)
    (               reduce using rule 21 (local_decls -> empty .)
    +               reduce using rule 21 (local_decls -> empty .)
    -               reduce using rule 21 (local_decls -> empty .)
    !               reduce using rule 21 (local_decls -> empty .)


state 36

    (22) local_decls -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . continue_stmt
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (40) continue_stmt -> . CONTINUE ;
    (13) func_decl -> . type_spec IDENT ( params ) compound_stmt
    (7) var_decl -> . type_spec IDENT [ ] ;
    (8) var_decl -> . type_spec IDENT ;
    (9) type_spec -> . FLOAT
    (10) type_spec -> . INT
    (11) type_spec -> . BOOL
    (12) type_spec -> . VOID
  ! shift/reduce conflict for CONTINUE resolved as shift
    BREAK           reduce using rule 22 (local_decls -> decl_list .)
    RETURN          reduce using rule 22 (local_decls -> decl_list .)
    WHILE           reduce using rule 22 (local_decls -> decl_list .)
    IF              reduce using rule 22 (local_decls -> decl_list .)
    {               reduce using rule 22 (local_decls -> decl_list .)
    ;               reduce using rule 22 (local_decls -> decl_list .)
    NEW             reduce using rule 22 (local_decls -> decl_list .)
    STRING_LIT      reduce using rule 22 (local_decls -> decl_list .)
    FLOAT_LIT       reduce using rule 22 (local_decls -> decl_list .)
    INT_LIT         reduce using rule 22 (local_decls -> decl_list .)
    BOOL_LIT        reduce using rule 22 (local_decls -> decl_list .)
    IDENT           reduce using rule 22 (local_decls -> decl_list .)
    (               reduce using rule 22 (local_decls -> decl_list .)
    +               reduce using rule 22 (local_decls -> decl_list .)
    -               reduce using rule 22 (local_decls -> decl_list .)
    !               reduce using rule 22 (local_decls -> decl_list .)
    CONTINUE        shift and go to state 7
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    decl                           shift and go to state 13
    continue_stmt                  shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 37

    (20) compound_stmt -> { local_decls stmt_list . }
    (24) stmt_list -> stmt_list . stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . return_stmt
    (28) stmt -> . while_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (40) continue_stmt -> . CONTINUE ;
    (39) break_stmt -> . BREAK ;
    (37) return_stmt -> . RETURN expr ;
    (38) return_stmt -> . RETURN ;
    (34) while_stmt -> . WHILE ( expr ) stmt
    (35) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt
    (20) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . ;
    (33) expr_stmt -> . expr ;
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    }               shift and go to state 62
    CONTINUE        shift and go to state 7
    BREAK           shift and go to state 47
    RETURN          shift and go to state 48
    WHILE           shift and go to state 50
    IF              shift and go to state 52
    {               shift and go to state 31
    ;               shift and go to state 46
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    stmt                           shift and go to state 63
    continue_stmt                  shift and go to state 39
    break_stmt                     shift and go to state 40
    return_stmt                    shift and go to state 41
    while_stmt                     shift and go to state 42
    if_stmt                        shift and go to state 43
    compound_stmt                  shift and go to state 44
    expr_stmt                      shift and go to state 45
    expr                           shift and go to state 49

state 38

    (23) stmt_list -> stmt .
    }               reduce using rule 23 (stmt_list -> stmt .)
    CONTINUE        reduce using rule 23 (stmt_list -> stmt .)
    BREAK           reduce using rule 23 (stmt_list -> stmt .)
    RETURN          reduce using rule 23 (stmt_list -> stmt .)
    WHILE           reduce using rule 23 (stmt_list -> stmt .)
    IF              reduce using rule 23 (stmt_list -> stmt .)
    {               reduce using rule 23 (stmt_list -> stmt .)
    ;               reduce using rule 23 (stmt_list -> stmt .)
    NEW             reduce using rule 23 (stmt_list -> stmt .)
    STRING_LIT      reduce using rule 23 (stmt_list -> stmt .)
    FLOAT_LIT       reduce using rule 23 (stmt_list -> stmt .)
    INT_LIT         reduce using rule 23 (stmt_list -> stmt .)
    BOOL_LIT        reduce using rule 23 (stmt_list -> stmt .)
    IDENT           reduce using rule 23 (stmt_list -> stmt .)
    (               reduce using rule 23 (stmt_list -> stmt .)
    +               reduce using rule 23 (stmt_list -> stmt .)
    -               reduce using rule 23 (stmt_list -> stmt .)
    !               reduce using rule 23 (stmt_list -> stmt .)


state 39

    (25) stmt -> continue_stmt .
    }               reduce using rule 25 (stmt -> continue_stmt .)
    CONTINUE        reduce using rule 25 (stmt -> continue_stmt .)
    BREAK           reduce using rule 25 (stmt -> continue_stmt .)
    RETURN          reduce using rule 25 (stmt -> continue_stmt .)
    WHILE           reduce using rule 25 (stmt -> continue_stmt .)
    IF              reduce using rule 25 (stmt -> continue_stmt .)
    {               reduce using rule 25 (stmt -> continue_stmt .)
    ;               reduce using rule 25 (stmt -> continue_stmt .)
    NEW             reduce using rule 25 (stmt -> continue_stmt .)
    STRING_LIT      reduce using rule 25 (stmt -> continue_stmt .)
    FLOAT_LIT       reduce using rule 25 (stmt -> continue_stmt .)
    INT_LIT         reduce using rule 25 (stmt -> continue_stmt .)
    BOOL_LIT        reduce using rule 25 (stmt -> continue_stmt .)
    IDENT           reduce using rule 25 (stmt -> continue_stmt .)
    (               reduce using rule 25 (stmt -> continue_stmt .)
    +               reduce using rule 25 (stmt -> continue_stmt .)
    -               reduce using rule 25 (stmt -> continue_stmt .)
    !               reduce using rule 25 (stmt -> continue_stmt .)
    ELSE            reduce using rule 25 (stmt -> continue_stmt .)


state 40

    (26) stmt -> break_stmt .
    }               reduce using rule 26 (stmt -> break_stmt .)
    CONTINUE        reduce using rule 26 (stmt -> break_stmt .)
    BREAK           reduce using rule 26 (stmt -> break_stmt .)
    RETURN          reduce using rule 26 (stmt -> break_stmt .)
    WHILE           reduce using rule 26 (stmt -> break_stmt .)
    IF              reduce using rule 26 (stmt -> break_stmt .)
    {               reduce using rule 26 (stmt -> break_stmt .)
    ;               reduce using rule 26 (stmt -> break_stmt .)
    NEW             reduce using rule 26 (stmt -> break_stmt .)
    STRING_LIT      reduce using rule 26 (stmt -> break_stmt .)
    FLOAT_LIT       reduce using rule 26 (stmt -> break_stmt .)
    INT_LIT         reduce using rule 26 (stmt -> break_stmt .)
    BOOL_LIT        reduce using rule 26 (stmt -> break_stmt .)
    IDENT           reduce using rule 26 (stmt -> break_stmt .)
    (               reduce using rule 26 (stmt -> break_stmt .)
    +               reduce using rule 26 (stmt -> break_stmt .)
    -               reduce using rule 26 (stmt -> break_stmt .)
    !               reduce using rule 26 (stmt -> break_stmt .)
    ELSE            reduce using rule 26 (stmt -> break_stmt .)


state 41

    (27) stmt -> return_stmt .
    }               reduce using rule 27 (stmt -> return_stmt .)
    CONTINUE        reduce using rule 27 (stmt -> return_stmt .)
    BREAK           reduce using rule 27 (stmt -> return_stmt .)
    RETURN          reduce using rule 27 (stmt -> return_stmt .)
    WHILE           reduce using rule 27 (stmt -> return_stmt .)
    IF              reduce using rule 27 (stmt -> return_stmt .)
    {               reduce using rule 27 (stmt -> return_stmt .)
    ;               reduce using rule 27 (stmt -> return_stmt .)
    NEW             reduce using rule 27 (stmt -> return_stmt .)
    STRING_LIT      reduce using rule 27 (stmt -> return_stmt .)
    FLOAT_LIT       reduce using rule 27 (stmt -> return_stmt .)
    INT_LIT         reduce using rule 27 (stmt -> return_stmt .)
    BOOL_LIT        reduce using rule 27 (stmt -> return_stmt .)
    IDENT           reduce using rule 27 (stmt -> return_stmt .)
    (               reduce using rule 27 (stmt -> return_stmt .)
    +               reduce using rule 27 (stmt -> return_stmt .)
    -               reduce using rule 27 (stmt -> return_stmt .)
    !               reduce using rule 27 (stmt -> return_stmt .)
    ELSE            reduce using rule 27 (stmt -> return_stmt .)


state 42

    (28) stmt -> while_stmt .
    }               reduce using rule 28 (stmt -> while_stmt .)
    CONTINUE        reduce using rule 28 (stmt -> while_stmt .)
    BREAK           reduce using rule 28 (stmt -> while_stmt .)
    RETURN          reduce using rule 28 (stmt -> while_stmt .)
    WHILE           reduce using rule 28 (stmt -> while_stmt .)
    IF              reduce using rule 28 (stmt -> while_stmt .)
    {               reduce using rule 28 (stmt -> while_stmt .)
    ;               reduce using rule 28 (stmt -> while_stmt .)
    NEW             reduce using rule 28 (stmt -> while_stmt .)
    STRING_LIT      reduce using rule 28 (stmt -> while_stmt .)
    FLOAT_LIT       reduce using rule 28 (stmt -> while_stmt .)
    INT_LIT         reduce using rule 28 (stmt -> while_stmt .)
    BOOL_LIT        reduce using rule 28 (stmt -> while_stmt .)
    IDENT           reduce using rule 28 (stmt -> while_stmt .)
    (               reduce using rule 28 (stmt -> while_stmt .)
    +               reduce using rule 28 (stmt -> while_stmt .)
    -               reduce using rule 28 (stmt -> while_stmt .)
    !               reduce using rule 28 (stmt -> while_stmt .)
    ELSE            reduce using rule 28 (stmt -> while_stmt .)


state 43

    (29) stmt -> if_stmt .
    }               reduce using rule 29 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 29 (stmt -> if_stmt .)
    BREAK           reduce using rule 29 (stmt -> if_stmt .)
    RETURN          reduce using rule 29 (stmt -> if_stmt .)
    WHILE           reduce using rule 29 (stmt -> if_stmt .)
    IF              reduce using rule 29 (stmt -> if_stmt .)
    {               reduce using rule 29 (stmt -> if_stmt .)
    ;               reduce using rule 29 (stmt -> if_stmt .)
    NEW             reduce using rule 29 (stmt -> if_stmt .)
    STRING_LIT      reduce using rule 29 (stmt -> if_stmt .)
    FLOAT_LIT       reduce using rule 29 (stmt -> if_stmt .)
    INT_LIT         reduce using rule 29 (stmt -> if_stmt .)
    BOOL_LIT        reduce using rule 29 (stmt -> if_stmt .)
    IDENT           reduce using rule 29 (stmt -> if_stmt .)
    (               reduce using rule 29 (stmt -> if_stmt .)
    +               reduce using rule 29 (stmt -> if_stmt .)
    -               reduce using rule 29 (stmt -> if_stmt .)
    !               reduce using rule 29 (stmt -> if_stmt .)
    ELSE            reduce using rule 29 (stmt -> if_stmt .)


state 44

    (30) stmt -> compound_stmt .
    }               reduce using rule 30 (stmt -> compound_stmt .)
    CONTINUE        reduce using rule 30 (stmt -> compound_stmt .)
    BREAK           reduce using rule 30 (stmt -> compound_stmt .)
    RETURN          reduce using rule 30 (stmt -> compound_stmt .)
    WHILE           reduce using rule 30 (stmt -> compound_stmt .)
    IF              reduce using rule 30 (stmt -> compound_stmt .)
    {               reduce using rule 30 (stmt -> compound_stmt .)
    ;               reduce using rule 30 (stmt -> compound_stmt .)
    NEW             reduce using rule 30 (stmt -> compound_stmt .)
    STRING_LIT      reduce using rule 30 (stmt -> compound_stmt .)
    FLOAT_LIT       reduce using rule 30 (stmt -> compound_stmt .)
    INT_LIT         reduce using rule 30 (stmt -> compound_stmt .)
    BOOL_LIT        reduce using rule 30 (stmt -> compound_stmt .)
    IDENT           reduce using rule 30 (stmt -> compound_stmt .)
    (               reduce using rule 30 (stmt -> compound_stmt .)
    +               reduce using rule 30 (stmt -> compound_stmt .)
    -               reduce using rule 30 (stmt -> compound_stmt .)
    !               reduce using rule 30 (stmt -> compound_stmt .)
    ELSE            reduce using rule 30 (stmt -> compound_stmt .)


state 45

    (31) stmt -> expr_stmt .
    }               reduce using rule 31 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 31 (stmt -> expr_stmt .)
    BREAK           reduce using rule 31 (stmt -> expr_stmt .)
    RETURN          reduce using rule 31 (stmt -> expr_stmt .)
    WHILE           reduce using rule 31 (stmt -> expr_stmt .)
    IF              reduce using rule 31 (stmt -> expr_stmt .)
    {               reduce using rule 31 (stmt -> expr_stmt .)
    ;               reduce using rule 31 (stmt -> expr_stmt .)
    NEW             reduce using rule 31 (stmt -> expr_stmt .)
    STRING_LIT      reduce using rule 31 (stmt -> expr_stmt .)
    FLOAT_LIT       reduce using rule 31 (stmt -> expr_stmt .)
    INT_LIT         reduce using rule 31 (stmt -> expr_stmt .)
    BOOL_LIT        reduce using rule 31 (stmt -> expr_stmt .)
    IDENT           reduce using rule 31 (stmt -> expr_stmt .)
    (               reduce using rule 31 (stmt -> expr_stmt .)
    +               reduce using rule 31 (stmt -> expr_stmt .)
    -               reduce using rule 31 (stmt -> expr_stmt .)
    !               reduce using rule 31 (stmt -> expr_stmt .)
    ELSE            reduce using rule 31 (stmt -> expr_stmt .)


state 46

    (32) expr_stmt -> ; .
    }               reduce using rule 32 (expr_stmt -> ; .)
    CONTINUE        reduce using rule 32 (expr_stmt -> ; .)
    BREAK           reduce using rule 32 (expr_stmt -> ; .)
    RETURN          reduce using rule 32 (expr_stmt -> ; .)
    WHILE           reduce using rule 32 (expr_stmt -> ; .)
    IF              reduce using rule 32 (expr_stmt -> ; .)
    {               reduce using rule 32 (expr_stmt -> ; .)
    ;               reduce using rule 32 (expr_stmt -> ; .)
    NEW             reduce using rule 32 (expr_stmt -> ; .)
    STRING_LIT      reduce using rule 32 (expr_stmt -> ; .)
    FLOAT_LIT       reduce using rule 32 (expr_stmt -> ; .)
    INT_LIT         reduce using rule 32 (expr_stmt -> ; .)
    BOOL_LIT        reduce using rule 32 (expr_stmt -> ; .)
    IDENT           reduce using rule 32 (expr_stmt -> ; .)
    (               reduce using rule 32 (expr_stmt -> ; .)
    +               reduce using rule 32 (expr_stmt -> ; .)
    -               reduce using rule 32 (expr_stmt -> ; .)
    !               reduce using rule 32 (expr_stmt -> ; .)
    ELSE            reduce using rule 32 (expr_stmt -> ; .)


state 47

    (39) break_stmt -> BREAK . ;
    ;               shift and go to state 64


state 48

    (37) return_stmt -> RETURN . expr ;
    (38) return_stmt -> RETURN . ;
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    ;               shift and go to state 66
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 65

state 49

    (33) expr_stmt -> expr . ;
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               shift and go to state 67
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    >               shift and go to state 73
    GE              shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    NE              shift and go to state 77
    EQ              shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80


state 50

    (34) while_stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 81


state 51

    (50) expr -> ( . expr )
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 82

state 52

    (35) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (36) if_stmt -> IF . ( expr ) stmt
    (               shift and go to state 83


state 53

    (41) expr -> NEW . type_spec [ expr ]
    (9) type_spec -> . FLOAT
    (10) type_spec -> . INT
    (11) type_spec -> . BOOL
    (12) type_spec -> . VOID
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    BOOL            shift and go to state 11
    VOID            shift and go to state 12

    type_spec                      shift and go to state 84

state 54

    (42) expr -> STRING_LIT .
    ;               reduce using rule 42 (expr -> STRING_LIT .)
    %               reduce using rule 42 (expr -> STRING_LIT .)
    /               reduce using rule 42 (expr -> STRING_LIT .)
    *               reduce using rule 42 (expr -> STRING_LIT .)
    -               reduce using rule 42 (expr -> STRING_LIT .)
    +               reduce using rule 42 (expr -> STRING_LIT .)
    >               reduce using rule 42 (expr -> STRING_LIT .)
    GE              reduce using rule 42 (expr -> STRING_LIT .)
    <               reduce using rule 42 (expr -> STRING_LIT .)
    LE              reduce using rule 42 (expr -> STRING_LIT .)
    NE              reduce using rule 42 (expr -> STRING_LIT .)
    EQ              reduce using rule 42 (expr -> STRING_LIT .)
    AND             reduce using rule 42 (expr -> STRING_LIT .)
    OR              reduce using rule 42 (expr -> STRING_LIT .)
    )               reduce using rule 42 (expr -> STRING_LIT .)
    ,               reduce using rule 42 (expr -> STRING_LIT .)
    ]               reduce using rule 42 (expr -> STRING_LIT .)


state 55

    (43) expr -> FLOAT_LIT .
    ;               reduce using rule 43 (expr -> FLOAT_LIT .)
    %               reduce using rule 43 (expr -> FLOAT_LIT .)
    /               reduce using rule 43 (expr -> FLOAT_LIT .)
    *               reduce using rule 43 (expr -> FLOAT_LIT .)
    -               reduce using rule 43 (expr -> FLOAT_LIT .)
    +               reduce using rule 43 (expr -> FLOAT_LIT .)
    >               reduce using rule 43 (expr -> FLOAT_LIT .)
    GE              reduce using rule 43 (expr -> FLOAT_LIT .)
    <               reduce using rule 43 (expr -> FLOAT_LIT .)
    LE              reduce using rule 43 (expr -> FLOAT_LIT .)
    NE              reduce using rule 43 (expr -> FLOAT_LIT .)
    EQ              reduce using rule 43 (expr -> FLOAT_LIT .)
    AND             reduce using rule 43 (expr -> FLOAT_LIT .)
    OR              reduce using rule 43 (expr -> FLOAT_LIT .)
    )               reduce using rule 43 (expr -> FLOAT_LIT .)
    ,               reduce using rule 43 (expr -> FLOAT_LIT .)
    ]               reduce using rule 43 (expr -> FLOAT_LIT .)


state 56

    (44) expr -> INT_LIT .
    ;               reduce using rule 44 (expr -> INT_LIT .)
    %               reduce using rule 44 (expr -> INT_LIT .)
    /               reduce using rule 44 (expr -> INT_LIT .)
    *               reduce using rule 44 (expr -> INT_LIT .)
    -               reduce using rule 44 (expr -> INT_LIT .)
    +               reduce using rule 44 (expr -> INT_LIT .)
    >               reduce using rule 44 (expr -> INT_LIT .)
    GE              reduce using rule 44 (expr -> INT_LIT .)
    <               reduce using rule 44 (expr -> INT_LIT .)
    LE              reduce using rule 44 (expr -> INT_LIT .)
    NE              reduce using rule 44 (expr -> INT_LIT .)
    EQ              reduce using rule 44 (expr -> INT_LIT .)
    AND             reduce using rule 44 (expr -> INT_LIT .)
    OR              reduce using rule 44 (expr -> INT_LIT .)
    )               reduce using rule 44 (expr -> INT_LIT .)
    ,               reduce using rule 44 (expr -> INT_LIT .)
    ]               reduce using rule 44 (expr -> INT_LIT .)


state 57

    (45) expr -> BOOL_LIT .
    ;               reduce using rule 45 (expr -> BOOL_LIT .)
    %               reduce using rule 45 (expr -> BOOL_LIT .)
    /               reduce using rule 45 (expr -> BOOL_LIT .)
    *               reduce using rule 45 (expr -> BOOL_LIT .)
    -               reduce using rule 45 (expr -> BOOL_LIT .)
    +               reduce using rule 45 (expr -> BOOL_LIT .)
    >               reduce using rule 45 (expr -> BOOL_LIT .)
    GE              reduce using rule 45 (expr -> BOOL_LIT .)
    <               reduce using rule 45 (expr -> BOOL_LIT .)
    LE              reduce using rule 45 (expr -> BOOL_LIT .)
    NE              reduce using rule 45 (expr -> BOOL_LIT .)
    EQ              reduce using rule 45 (expr -> BOOL_LIT .)
    AND             reduce using rule 45 (expr -> BOOL_LIT .)
    OR              reduce using rule 45 (expr -> BOOL_LIT .)
    )               reduce using rule 45 (expr -> BOOL_LIT .)
    ,               reduce using rule 45 (expr -> BOOL_LIT .)
    ]               reduce using rule 45 (expr -> BOOL_LIT .)


state 58

    (46) expr -> IDENT . . SIZE
    (47) expr -> IDENT . ( args )
    (48) expr -> IDENT . [ expr ]
    (49) expr -> IDENT .
    (67) expr -> IDENT . [ expr ] = expr
    (68) expr -> IDENT . = expr
    .               shift and go to state 85
    (               shift and go to state 86
    [               shift and go to state 87
    ;               reduce using rule 49 (expr -> IDENT .)
    %               reduce using rule 49 (expr -> IDENT .)
    /               reduce using rule 49 (expr -> IDENT .)
    *               reduce using rule 49 (expr -> IDENT .)
    -               reduce using rule 49 (expr -> IDENT .)
    +               reduce using rule 49 (expr -> IDENT .)
    >               reduce using rule 49 (expr -> IDENT .)
    GE              reduce using rule 49 (expr -> IDENT .)
    <               reduce using rule 49 (expr -> IDENT .)
    LE              reduce using rule 49 (expr -> IDENT .)
    NE              reduce using rule 49 (expr -> IDENT .)
    EQ              reduce using rule 49 (expr -> IDENT .)
    AND             reduce using rule 49 (expr -> IDENT .)
    OR              reduce using rule 49 (expr -> IDENT .)
    )               reduce using rule 49 (expr -> IDENT .)
    ,               reduce using rule 49 (expr -> IDENT .)
    ]               reduce using rule 49 (expr -> IDENT .)
    =               shift and go to state 88


state 59

    (51) expr -> + . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 89

state 60

    (52) expr -> - . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 90

state 61

    (53) expr -> ! . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 91

state 62

    (20) compound_stmt -> { local_decls stmt_list } .
    CONTINUE        reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT           reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    BOOL            reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    VOID            reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    BREAK           reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    RETURN          reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    WHILE           reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    IF              reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    {               reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    ;               reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    NEW             reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    STRING_LIT      reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT_LIT       reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    INT_LIT         reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    BOOL_LIT        reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    IDENT           reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    (               reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    +               reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    -               reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    !               reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    }               reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)
    ELSE            reduce using rule 20 (compound_stmt -> { local_decls stmt_list } .)


state 63

    (24) stmt_list -> stmt_list stmt .
    }               reduce using rule 24 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 24 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 24 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 24 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 24 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 24 (stmt_list -> stmt_list stmt .)
    {               reduce using rule 24 (stmt_list -> stmt_list stmt .)
    ;               reduce using rule 24 (stmt_list -> stmt_list stmt .)
    NEW             reduce using rule 24 (stmt_list -> stmt_list stmt .)
    STRING_LIT      reduce using rule 24 (stmt_list -> stmt_list stmt .)
    FLOAT_LIT       reduce using rule 24 (stmt_list -> stmt_list stmt .)
    INT_LIT         reduce using rule 24 (stmt_list -> stmt_list stmt .)
    BOOL_LIT        reduce using rule 24 (stmt_list -> stmt_list stmt .)
    IDENT           reduce using rule 24 (stmt_list -> stmt_list stmt .)
    (               reduce using rule 24 (stmt_list -> stmt_list stmt .)
    +               reduce using rule 24 (stmt_list -> stmt_list stmt .)
    -               reduce using rule 24 (stmt_list -> stmt_list stmt .)
    !               reduce using rule 24 (stmt_list -> stmt_list stmt .)


state 64

    (39) break_stmt -> BREAK ; .
    }               reduce using rule 39 (break_stmt -> BREAK ; .)
    CONTINUE        reduce using rule 39 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 39 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 39 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 39 (break_stmt -> BREAK ; .)
    IF              reduce using rule 39 (break_stmt -> BREAK ; .)
    {               reduce using rule 39 (break_stmt -> BREAK ; .)
    ;               reduce using rule 39 (break_stmt -> BREAK ; .)
    NEW             reduce using rule 39 (break_stmt -> BREAK ; .)
    STRING_LIT      reduce using rule 39 (break_stmt -> BREAK ; .)
    FLOAT_LIT       reduce using rule 39 (break_stmt -> BREAK ; .)
    INT_LIT         reduce using rule 39 (break_stmt -> BREAK ; .)
    BOOL_LIT        reduce using rule 39 (break_stmt -> BREAK ; .)
    IDENT           reduce using rule 39 (break_stmt -> BREAK ; .)
    (               reduce using rule 39 (break_stmt -> BREAK ; .)
    +               reduce using rule 39 (break_stmt -> BREAK ; .)
    -               reduce using rule 39 (break_stmt -> BREAK ; .)
    !               reduce using rule 39 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 39 (break_stmt -> BREAK ; .)


state 65

    (37) return_stmt -> RETURN expr . ;
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               shift and go to state 92
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    >               shift and go to state 73
    GE              shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    NE              shift and go to state 77
    EQ              shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80


state 66

    (38) return_stmt -> RETURN ; .
    }               reduce using rule 38 (return_stmt -> RETURN ; .)
    CONTINUE        reduce using rule 38 (return_stmt -> RETURN ; .)
    BREAK           reduce using rule 38 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 38 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 38 (return_stmt -> RETURN ; .)
    IF              reduce using rule 38 (return_stmt -> RETURN ; .)
    {               reduce using rule 38 (return_stmt -> RETURN ; .)
    ;               reduce using rule 38 (return_stmt -> RETURN ; .)
    NEW             reduce using rule 38 (return_stmt -> RETURN ; .)
    STRING_LIT      reduce using rule 38 (return_stmt -> RETURN ; .)
    FLOAT_LIT       reduce using rule 38 (return_stmt -> RETURN ; .)
    INT_LIT         reduce using rule 38 (return_stmt -> RETURN ; .)
    BOOL_LIT        reduce using rule 38 (return_stmt -> RETURN ; .)
    IDENT           reduce using rule 38 (return_stmt -> RETURN ; .)
    (               reduce using rule 38 (return_stmt -> RETURN ; .)
    +               reduce using rule 38 (return_stmt -> RETURN ; .)
    -               reduce using rule 38 (return_stmt -> RETURN ; .)
    !               reduce using rule 38 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 38 (return_stmt -> RETURN ; .)


state 67

    (33) expr_stmt -> expr ; .
    }               reduce using rule 33 (expr_stmt -> expr ; .)
    CONTINUE        reduce using rule 33 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 33 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 33 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 33 (expr_stmt -> expr ; .)
    IF              reduce using rule 33 (expr_stmt -> expr ; .)
    {               reduce using rule 33 (expr_stmt -> expr ; .)
    ;               reduce using rule 33 (expr_stmt -> expr ; .)
    NEW             reduce using rule 33 (expr_stmt -> expr ; .)
    STRING_LIT      reduce using rule 33 (expr_stmt -> expr ; .)
    FLOAT_LIT       reduce using rule 33 (expr_stmt -> expr ; .)
    INT_LIT         reduce using rule 33 (expr_stmt -> expr ; .)
    BOOL_LIT        reduce using rule 33 (expr_stmt -> expr ; .)
    IDENT           reduce using rule 33 (expr_stmt -> expr ; .)
    (               reduce using rule 33 (expr_stmt -> expr ; .)
    +               reduce using rule 33 (expr_stmt -> expr ; .)
    -               reduce using rule 33 (expr_stmt -> expr ; .)
    !               reduce using rule 33 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 33 (expr_stmt -> expr ; .)


state 68

    (54) expr -> expr % . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 93

state 69

    (55) expr -> expr / . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 94

state 70

    (56) expr -> expr * . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 95

state 71

    (57) expr -> expr - . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 96

state 72

    (58) expr -> expr + . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 97

state 73

    (59) expr -> expr > . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 98

state 74

    (60) expr -> expr GE . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 99

state 75

    (61) expr -> expr < . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 100

state 76

    (62) expr -> expr LE . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 101

state 77

    (63) expr -> expr NE . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 102

state 78

    (64) expr -> expr EQ . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 103

state 79

    (65) expr -> expr AND . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 104

state 80

    (66) expr -> expr OR . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 105

state 81

    (34) while_stmt -> WHILE ( . expr ) stmt
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 106

state 82

    (50) expr -> ( expr . )
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    )               shift and go to state 107
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    >               shift and go to state 73
    GE              shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    NE              shift and go to state 77
    EQ              shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80


state 83

    (35) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (36) if_stmt -> IF ( . expr ) stmt
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 108

state 84

    (41) expr -> NEW type_spec . [ expr ]
    [               shift and go to state 109


state 85

    (46) expr -> IDENT . . SIZE
    SIZE            shift and go to state 110


state 86

    (47) expr -> IDENT ( . args )
    (69) args -> . arg_list
    (70) arg_list -> . expr
    (71) arg_list -> . arg_list , expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    args                           shift and go to state 111
    arg_list                       shift and go to state 112
    expr                           shift and go to state 113

state 87

    (48) expr -> IDENT [ . expr ]
    (67) expr -> IDENT [ . expr ] = expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 114

state 88

    (68) expr -> IDENT = . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 115

state 89

    (51) expr -> + expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 51 (expr -> + expr .)
    %               reduce using rule 51 (expr -> + expr .)
    /               reduce using rule 51 (expr -> + expr .)
    *               reduce using rule 51 (expr -> + expr .)
    -               reduce using rule 51 (expr -> + expr .)
    +               reduce using rule 51 (expr -> + expr .)
    >               reduce using rule 51 (expr -> + expr .)
    GE              reduce using rule 51 (expr -> + expr .)
    <               reduce using rule 51 (expr -> + expr .)
    LE              reduce using rule 51 (expr -> + expr .)
    NE              reduce using rule 51 (expr -> + expr .)
    EQ              reduce using rule 51 (expr -> + expr .)
    AND             reduce using rule 51 (expr -> + expr .)
    OR              reduce using rule 51 (expr -> + expr .)
    )               reduce using rule 51 (expr -> + expr .)
    ,               reduce using rule 51 (expr -> + expr .)
    ]               reduce using rule 51 (expr -> + expr .)


state 90

    (52) expr -> - expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 52 (expr -> - expr .)
    %               reduce using rule 52 (expr -> - expr .)
    /               reduce using rule 52 (expr -> - expr .)
    *               reduce using rule 52 (expr -> - expr .)
    -               reduce using rule 52 (expr -> - expr .)
    +               reduce using rule 52 (expr -> - expr .)
    >               reduce using rule 52 (expr -> - expr .)
    GE              reduce using rule 52 (expr -> - expr .)
    <               reduce using rule 52 (expr -> - expr .)
    LE              reduce using rule 52 (expr -> - expr .)
    NE              reduce using rule 52 (expr -> - expr .)
    EQ              reduce using rule 52 (expr -> - expr .)
    AND             reduce using rule 52 (expr -> - expr .)
    OR              reduce using rule 52 (expr -> - expr .)
    )               reduce using rule 52 (expr -> - expr .)
    ,               reduce using rule 52 (expr -> - expr .)
    ]               reduce using rule 52 (expr -> - expr .)


state 91

    (53) expr -> ! expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 53 (expr -> ! expr .)
    %               reduce using rule 53 (expr -> ! expr .)
    /               reduce using rule 53 (expr -> ! expr .)
    *               reduce using rule 53 (expr -> ! expr .)
    -               reduce using rule 53 (expr -> ! expr .)
    +               reduce using rule 53 (expr -> ! expr .)
    >               reduce using rule 53 (expr -> ! expr .)
    GE              reduce using rule 53 (expr -> ! expr .)
    <               reduce using rule 53 (expr -> ! expr .)
    LE              reduce using rule 53 (expr -> ! expr .)
    NE              reduce using rule 53 (expr -> ! expr .)
    EQ              reduce using rule 53 (expr -> ! expr .)
    AND             reduce using rule 53 (expr -> ! expr .)
    OR              reduce using rule 53 (expr -> ! expr .)
    )               reduce using rule 53 (expr -> ! expr .)
    ,               reduce using rule 53 (expr -> ! expr .)
    ]               reduce using rule 53 (expr -> ! expr .)


state 92

    (37) return_stmt -> RETURN expr ; .
    }               reduce using rule 37 (return_stmt -> RETURN expr ; .)
    CONTINUE        reduce using rule 37 (return_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 37 (return_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 37 (return_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 37 (return_stmt -> RETURN expr ; .)
    IF              reduce using rule 37 (return_stmt -> RETURN expr ; .)
    {               reduce using rule 37 (return_stmt -> RETURN expr ; .)
    ;               reduce using rule 37 (return_stmt -> RETURN expr ; .)
    NEW             reduce using rule 37 (return_stmt -> RETURN expr ; .)
    STRING_LIT      reduce using rule 37 (return_stmt -> RETURN expr ; .)
    FLOAT_LIT       reduce using rule 37 (return_stmt -> RETURN expr ; .)
    INT_LIT         reduce using rule 37 (return_stmt -> RETURN expr ; .)
    BOOL_LIT        reduce using rule 37 (return_stmt -> RETURN expr ; .)
    IDENT           reduce using rule 37 (return_stmt -> RETURN expr ; .)
    (               reduce using rule 37 (return_stmt -> RETURN expr ; .)
    +               reduce using rule 37 (return_stmt -> RETURN expr ; .)
    -               reduce using rule 37 (return_stmt -> RETURN expr ; .)
    !               reduce using rule 37 (return_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 37 (return_stmt -> RETURN expr ; .)


state 93

    (54) expr -> expr % expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 54 (expr -> expr % expr .)
    %               reduce using rule 54 (expr -> expr % expr .)
    /               reduce using rule 54 (expr -> expr % expr .)
    *               reduce using rule 54 (expr -> expr % expr .)
    -               reduce using rule 54 (expr -> expr % expr .)
    +               reduce using rule 54 (expr -> expr % expr .)
    >               reduce using rule 54 (expr -> expr % expr .)
    GE              reduce using rule 54 (expr -> expr % expr .)
    <               reduce using rule 54 (expr -> expr % expr .)
    LE              reduce using rule 54 (expr -> expr % expr .)
    NE              reduce using rule 54 (expr -> expr % expr .)
    EQ              reduce using rule 54 (expr -> expr % expr .)
    AND             reduce using rule 54 (expr -> expr % expr .)
    OR              reduce using rule 54 (expr -> expr % expr .)
    )               reduce using rule 54 (expr -> expr % expr .)
    ,               reduce using rule 54 (expr -> expr % expr .)
    ]               reduce using rule 54 (expr -> expr % expr .)


state 94

    (55) expr -> expr / expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 55 (expr -> expr / expr .)
    %               reduce using rule 55 (expr -> expr / expr .)
    /               reduce using rule 55 (expr -> expr / expr .)
    *               reduce using rule 55 (expr -> expr / expr .)
    -               reduce using rule 55 (expr -> expr / expr .)
    +               reduce using rule 55 (expr -> expr / expr .)
    >               reduce using rule 55 (expr -> expr / expr .)
    GE              reduce using rule 55 (expr -> expr / expr .)
    <               reduce using rule 55 (expr -> expr / expr .)
    LE              reduce using rule 55 (expr -> expr / expr .)
    NE              reduce using rule 55 (expr -> expr / expr .)
    EQ              reduce using rule 55 (expr -> expr / expr .)
    AND             reduce using rule 55 (expr -> expr / expr .)
    OR              reduce using rule 55 (expr -> expr / expr .)
    )               reduce using rule 55 (expr -> expr / expr .)
    ,               reduce using rule 55 (expr -> expr / expr .)
    ]               reduce using rule 55 (expr -> expr / expr .)


state 95

    (56) expr -> expr * expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 56 (expr -> expr * expr .)
    %               reduce using rule 56 (expr -> expr * expr .)
    /               reduce using rule 56 (expr -> expr * expr .)
    *               reduce using rule 56 (expr -> expr * expr .)
    -               reduce using rule 56 (expr -> expr * expr .)
    +               reduce using rule 56 (expr -> expr * expr .)
    >               reduce using rule 56 (expr -> expr * expr .)
    GE              reduce using rule 56 (expr -> expr * expr .)
    <               reduce using rule 56 (expr -> expr * expr .)
    LE              reduce using rule 56 (expr -> expr * expr .)
    NE              reduce using rule 56 (expr -> expr * expr .)
    EQ              reduce using rule 56 (expr -> expr * expr .)
    AND             reduce using rule 56 (expr -> expr * expr .)
    OR              reduce using rule 56 (expr -> expr * expr .)
    )               reduce using rule 56 (expr -> expr * expr .)
    ,               reduce using rule 56 (expr -> expr * expr .)
    ]               reduce using rule 56 (expr -> expr * expr .)


state 96

    (57) expr -> expr - expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 57 (expr -> expr - expr .)
    -               reduce using rule 57 (expr -> expr - expr .)
    +               reduce using rule 57 (expr -> expr - expr .)
    >               reduce using rule 57 (expr -> expr - expr .)
    GE              reduce using rule 57 (expr -> expr - expr .)
    <               reduce using rule 57 (expr -> expr - expr .)
    LE              reduce using rule 57 (expr -> expr - expr .)
    NE              reduce using rule 57 (expr -> expr - expr .)
    EQ              reduce using rule 57 (expr -> expr - expr .)
    AND             reduce using rule 57 (expr -> expr - expr .)
    OR              reduce using rule 57 (expr -> expr - expr .)
    )               reduce using rule 57 (expr -> expr - expr .)
    ,               reduce using rule 57 (expr -> expr - expr .)
    ]               reduce using rule 57 (expr -> expr - expr .)
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70


state 97

    (58) expr -> expr + expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 58 (expr -> expr + expr .)
    -               reduce using rule 58 (expr -> expr + expr .)
    +               reduce using rule 58 (expr -> expr + expr .)
    >               reduce using rule 58 (expr -> expr + expr .)
    GE              reduce using rule 58 (expr -> expr + expr .)
    <               reduce using rule 58 (expr -> expr + expr .)
    LE              reduce using rule 58 (expr -> expr + expr .)
    NE              reduce using rule 58 (expr -> expr + expr .)
    EQ              reduce using rule 58 (expr -> expr + expr .)
    AND             reduce using rule 58 (expr -> expr + expr .)
    OR              reduce using rule 58 (expr -> expr + expr .)
    )               reduce using rule 58 (expr -> expr + expr .)
    ,               reduce using rule 58 (expr -> expr + expr .)
    ]               reduce using rule 58 (expr -> expr + expr .)
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70


state 98

    (59) expr -> expr > expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 59 (expr -> expr > expr .)
    >               reduce using rule 59 (expr -> expr > expr .)
    GE              reduce using rule 59 (expr -> expr > expr .)
    <               reduce using rule 59 (expr -> expr > expr .)
    LE              reduce using rule 59 (expr -> expr > expr .)
    NE              reduce using rule 59 (expr -> expr > expr .)
    EQ              reduce using rule 59 (expr -> expr > expr .)
    AND             reduce using rule 59 (expr -> expr > expr .)
    OR              reduce using rule 59 (expr -> expr > expr .)
    )               reduce using rule 59 (expr -> expr > expr .)
    ,               reduce using rule 59 (expr -> expr > expr .)
    ]               reduce using rule 59 (expr -> expr > expr .)
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72


state 99

    (60) expr -> expr GE expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 60 (expr -> expr GE expr .)
    >               reduce using rule 60 (expr -> expr GE expr .)
    GE              reduce using rule 60 (expr -> expr GE expr .)
    <               reduce using rule 60 (expr -> expr GE expr .)
    LE              reduce using rule 60 (expr -> expr GE expr .)
    NE              reduce using rule 60 (expr -> expr GE expr .)
    EQ              reduce using rule 60 (expr -> expr GE expr .)
    AND             reduce using rule 60 (expr -> expr GE expr .)
    OR              reduce using rule 60 (expr -> expr GE expr .)
    )               reduce using rule 60 (expr -> expr GE expr .)
    ,               reduce using rule 60 (expr -> expr GE expr .)
    ]               reduce using rule 60 (expr -> expr GE expr .)
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72


state 100

    (61) expr -> expr < expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 61 (expr -> expr < expr .)
    >               reduce using rule 61 (expr -> expr < expr .)
    GE              reduce using rule 61 (expr -> expr < expr .)
    <               reduce using rule 61 (expr -> expr < expr .)
    LE              reduce using rule 61 (expr -> expr < expr .)
    NE              reduce using rule 61 (expr -> expr < expr .)
    EQ              reduce using rule 61 (expr -> expr < expr .)
    AND             reduce using rule 61 (expr -> expr < expr .)
    OR              reduce using rule 61 (expr -> expr < expr .)
    )               reduce using rule 61 (expr -> expr < expr .)
    ,               reduce using rule 61 (expr -> expr < expr .)
    ]               reduce using rule 61 (expr -> expr < expr .)
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72


state 101

    (62) expr -> expr LE expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 62 (expr -> expr LE expr .)
    >               reduce using rule 62 (expr -> expr LE expr .)
    GE              reduce using rule 62 (expr -> expr LE expr .)
    <               reduce using rule 62 (expr -> expr LE expr .)
    LE              reduce using rule 62 (expr -> expr LE expr .)
    NE              reduce using rule 62 (expr -> expr LE expr .)
    EQ              reduce using rule 62 (expr -> expr LE expr .)
    AND             reduce using rule 62 (expr -> expr LE expr .)
    OR              reduce using rule 62 (expr -> expr LE expr .)
    )               reduce using rule 62 (expr -> expr LE expr .)
    ,               reduce using rule 62 (expr -> expr LE expr .)
    ]               reduce using rule 62 (expr -> expr LE expr .)
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72


state 102

    (63) expr -> expr NE expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 63 (expr -> expr NE expr .)
    NE              reduce using rule 63 (expr -> expr NE expr .)
    EQ              reduce using rule 63 (expr -> expr NE expr .)
    AND             reduce using rule 63 (expr -> expr NE expr .)
    OR              reduce using rule 63 (expr -> expr NE expr .)
    )               reduce using rule 63 (expr -> expr NE expr .)
    ,               reduce using rule 63 (expr -> expr NE expr .)
    ]               reduce using rule 63 (expr -> expr NE expr .)
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    >               shift and go to state 73
    GE              shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76


state 103

    (64) expr -> expr EQ expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 64 (expr -> expr EQ expr .)
    NE              reduce using rule 64 (expr -> expr EQ expr .)
    EQ              reduce using rule 64 (expr -> expr EQ expr .)
    AND             reduce using rule 64 (expr -> expr EQ expr .)
    OR              reduce using rule 64 (expr -> expr EQ expr .)
    )               reduce using rule 64 (expr -> expr EQ expr .)
    ,               reduce using rule 64 (expr -> expr EQ expr .)
    ]               reduce using rule 64 (expr -> expr EQ expr .)
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    >               shift and go to state 73
    GE              shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76


state 104

    (65) expr -> expr AND expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 65 (expr -> expr AND expr .)
    AND             reduce using rule 65 (expr -> expr AND expr .)
    OR              reduce using rule 65 (expr -> expr AND expr .)
    )               reduce using rule 65 (expr -> expr AND expr .)
    ,               reduce using rule 65 (expr -> expr AND expr .)
    ]               reduce using rule 65 (expr -> expr AND expr .)
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    >               shift and go to state 73
    GE              shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    NE              shift and go to state 77
    EQ              shift and go to state 78


state 105

    (66) expr -> expr OR expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 66 (expr -> expr OR expr .)
    OR              reduce using rule 66 (expr -> expr OR expr .)
    )               reduce using rule 66 (expr -> expr OR expr .)
    ,               reduce using rule 66 (expr -> expr OR expr .)
    ]               reduce using rule 66 (expr -> expr OR expr .)
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    >               shift and go to state 73
    GE              shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    NE              shift and go to state 77
    EQ              shift and go to state 78
    AND             shift and go to state 79


state 106

    (34) while_stmt -> WHILE ( expr . ) stmt
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    )               shift and go to state 116
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    >               shift and go to state 73
    GE              shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    NE              shift and go to state 77
    EQ              shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80


state 107

    (50) expr -> ( expr ) .
    ;               reduce using rule 50 (expr -> ( expr ) .)
    %               reduce using rule 50 (expr -> ( expr ) .)
    /               reduce using rule 50 (expr -> ( expr ) .)
    *               reduce using rule 50 (expr -> ( expr ) .)
    -               reduce using rule 50 (expr -> ( expr ) .)
    +               reduce using rule 50 (expr -> ( expr ) .)
    >               reduce using rule 50 (expr -> ( expr ) .)
    GE              reduce using rule 50 (expr -> ( expr ) .)
    <               reduce using rule 50 (expr -> ( expr ) .)
    LE              reduce using rule 50 (expr -> ( expr ) .)
    NE              reduce using rule 50 (expr -> ( expr ) .)
    EQ              reduce using rule 50 (expr -> ( expr ) .)
    AND             reduce using rule 50 (expr -> ( expr ) .)
    OR              reduce using rule 50 (expr -> ( expr ) .)
    )               reduce using rule 50 (expr -> ( expr ) .)
    ,               reduce using rule 50 (expr -> ( expr ) .)
    ]               reduce using rule 50 (expr -> ( expr ) .)


state 108

    (35) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (36) if_stmt -> IF ( expr . ) stmt
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    )               shift and go to state 117
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    >               shift and go to state 73
    GE              shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    NE              shift and go to state 77
    EQ              shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80


state 109

    (41) expr -> NEW type_spec [ . expr ]
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 118

state 110

    (46) expr -> IDENT . SIZE .
    ;               reduce using rule 46 (expr -> IDENT . SIZE .)
    %               reduce using rule 46 (expr -> IDENT . SIZE .)
    /               reduce using rule 46 (expr -> IDENT . SIZE .)
    *               reduce using rule 46 (expr -> IDENT . SIZE .)
    -               reduce using rule 46 (expr -> IDENT . SIZE .)
    +               reduce using rule 46 (expr -> IDENT . SIZE .)
    >               reduce using rule 46 (expr -> IDENT . SIZE .)
    GE              reduce using rule 46 (expr -> IDENT . SIZE .)
    <               reduce using rule 46 (expr -> IDENT . SIZE .)
    LE              reduce using rule 46 (expr -> IDENT . SIZE .)
    NE              reduce using rule 46 (expr -> IDENT . SIZE .)
    EQ              reduce using rule 46 (expr -> IDENT . SIZE .)
    AND             reduce using rule 46 (expr -> IDENT . SIZE .)
    OR              reduce using rule 46 (expr -> IDENT . SIZE .)
    )               reduce using rule 46 (expr -> IDENT . SIZE .)
    ,               reduce using rule 46 (expr -> IDENT . SIZE .)
    ]               reduce using rule 46 (expr -> IDENT . SIZE .)


state 111

    (47) expr -> IDENT ( args . )
    )               shift and go to state 119


state 112

    (69) args -> arg_list .
    (71) arg_list -> arg_list . , expr
    )               reduce using rule 69 (args -> arg_list .)
    ,               shift and go to state 120


state 113

    (70) arg_list -> expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ,               reduce using rule 70 (arg_list -> expr .)
    )               reduce using rule 70 (arg_list -> expr .)
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    >               shift and go to state 73
    GE              shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    NE              shift and go to state 77
    EQ              shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80


state 114

    (48) expr -> IDENT [ expr . ]
    (67) expr -> IDENT [ expr . ] = expr
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ]               shift and go to state 121
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    >               shift and go to state 73
    GE              shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    NE              shift and go to state 77
    EQ              shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80


state 115

    (68) expr -> IDENT = expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 68 (expr -> IDENT = expr .)
    )               reduce using rule 68 (expr -> IDENT = expr .)
    ,               reduce using rule 68 (expr -> IDENT = expr .)
    ]               reduce using rule 68 (expr -> IDENT = expr .)
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    >               shift and go to state 73
    GE              shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    NE              shift and go to state 77
    EQ              shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80


state 116

    (34) while_stmt -> WHILE ( expr ) . stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . return_stmt
    (28) stmt -> . while_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (40) continue_stmt -> . CONTINUE ;
    (39) break_stmt -> . BREAK ;
    (37) return_stmt -> . RETURN expr ;
    (38) return_stmt -> . RETURN ;
    (34) while_stmt -> . WHILE ( expr ) stmt
    (35) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt
    (20) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . ;
    (33) expr_stmt -> . expr ;
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    CONTINUE        shift and go to state 7
    BREAK           shift and go to state 47
    RETURN          shift and go to state 48
    WHILE           shift and go to state 50
    IF              shift and go to state 52
    {               shift and go to state 31
    ;               shift and go to state 46
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 49
    stmt                           shift and go to state 122
    continue_stmt                  shift and go to state 39
    break_stmt                     shift and go to state 40
    return_stmt                    shift and go to state 41
    while_stmt                     shift and go to state 42
    if_stmt                        shift and go to state 43
    compound_stmt                  shift and go to state 44
    expr_stmt                      shift and go to state 45

state 117

    (35) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (36) if_stmt -> IF ( expr ) . stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . return_stmt
    (28) stmt -> . while_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (40) continue_stmt -> . CONTINUE ;
    (39) break_stmt -> . BREAK ;
    (37) return_stmt -> . RETURN expr ;
    (38) return_stmt -> . RETURN ;
    (34) while_stmt -> . WHILE ( expr ) stmt
    (35) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt
    (20) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . ;
    (33) expr_stmt -> . expr ;
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    CONTINUE        shift and go to state 7
    BREAK           shift and go to state 47
    RETURN          shift and go to state 48
    WHILE           shift and go to state 50
    IF              shift and go to state 52
    {               shift and go to state 31
    ;               shift and go to state 46
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 49
    stmt                           shift and go to state 123
    continue_stmt                  shift and go to state 39
    break_stmt                     shift and go to state 40
    return_stmt                    shift and go to state 41
    while_stmt                     shift and go to state 42
    if_stmt                        shift and go to state 43
    compound_stmt                  shift and go to state 44
    expr_stmt                      shift and go to state 45

state 118

    (41) expr -> NEW type_spec [ expr . ]
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ]               shift and go to state 124
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    >               shift and go to state 73
    GE              shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    NE              shift and go to state 77
    EQ              shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80


state 119

    (47) expr -> IDENT ( args ) .
    ;               reduce using rule 47 (expr -> IDENT ( args ) .)
    %               reduce using rule 47 (expr -> IDENT ( args ) .)
    /               reduce using rule 47 (expr -> IDENT ( args ) .)
    *               reduce using rule 47 (expr -> IDENT ( args ) .)
    -               reduce using rule 47 (expr -> IDENT ( args ) .)
    +               reduce using rule 47 (expr -> IDENT ( args ) .)
    >               reduce using rule 47 (expr -> IDENT ( args ) .)
    GE              reduce using rule 47 (expr -> IDENT ( args ) .)
    <               reduce using rule 47 (expr -> IDENT ( args ) .)
    LE              reduce using rule 47 (expr -> IDENT ( args ) .)
    NE              reduce using rule 47 (expr -> IDENT ( args ) .)
    EQ              reduce using rule 47 (expr -> IDENT ( args ) .)
    AND             reduce using rule 47 (expr -> IDENT ( args ) .)
    OR              reduce using rule 47 (expr -> IDENT ( args ) .)
    )               reduce using rule 47 (expr -> IDENT ( args ) .)
    ,               reduce using rule 47 (expr -> IDENT ( args ) .)
    ]               reduce using rule 47 (expr -> IDENT ( args ) .)


state 120

    (71) arg_list -> arg_list , . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 125

state 121

    (48) expr -> IDENT [ expr ] .
    (67) expr -> IDENT [ expr ] . = expr
    ;               reduce using rule 48 (expr -> IDENT [ expr ] .)
    %               reduce using rule 48 (expr -> IDENT [ expr ] .)
    /               reduce using rule 48 (expr -> IDENT [ expr ] .)
    *               reduce using rule 48 (expr -> IDENT [ expr ] .)
    -               reduce using rule 48 (expr -> IDENT [ expr ] .)
    +               reduce using rule 48 (expr -> IDENT [ expr ] .)
    >               reduce using rule 48 (expr -> IDENT [ expr ] .)
    GE              reduce using rule 48 (expr -> IDENT [ expr ] .)
    <               reduce using rule 48 (expr -> IDENT [ expr ] .)
    LE              reduce using rule 48 (expr -> IDENT [ expr ] .)
    NE              reduce using rule 48 (expr -> IDENT [ expr ] .)
    EQ              reduce using rule 48 (expr -> IDENT [ expr ] .)
    AND             reduce using rule 48 (expr -> IDENT [ expr ] .)
    OR              reduce using rule 48 (expr -> IDENT [ expr ] .)
    )               reduce using rule 48 (expr -> IDENT [ expr ] .)
    ,               reduce using rule 48 (expr -> IDENT [ expr ] .)
    ]               reduce using rule 48 (expr -> IDENT [ expr ] .)
    =               shift and go to state 126


state 122

    (34) while_stmt -> WHILE ( expr ) stmt .
    }               reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    ;               reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    NEW             reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    STRING_LIT      reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    INT_LIT         reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    BOOL_LIT        reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    IDENT           reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    +               reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 34 (while_stmt -> WHILE ( expr ) stmt .)


state 123

    (35) if_stmt -> IF ( expr ) stmt . ELSE stmt
    (36) if_stmt -> IF ( expr ) stmt .
    ELSE            shift and go to state 127
    }               reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    ;               reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    NEW             reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    STRING_LIT      reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    INT_LIT         reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    BOOL_LIT        reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 36 (if_stmt -> IF ( expr ) stmt .)


state 124

    (41) expr -> NEW type_spec [ expr ] .
    ;               reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    %               reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    /               reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    *               reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    -               reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    +               reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    >               reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    GE              reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    <               reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    LE              reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    NE              reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    EQ              reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    AND             reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    OR              reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    )               reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    ,               reduce using rule 41 (expr -> NEW type_spec [ expr ] .)
    ]               reduce using rule 41 (expr -> NEW type_spec [ expr ] .)


state 125

    (71) arg_list -> arg_list , expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ,               reduce using rule 71 (arg_list -> arg_list , expr .)
    )               reduce using rule 71 (arg_list -> arg_list , expr .)
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    >               shift and go to state 73
    GE              shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    NE              shift and go to state 77
    EQ              shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80


state 126

    (67) expr -> IDENT [ expr ] = . expr
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 128

state 127

    (35) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . return_stmt
    (28) stmt -> . while_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (40) continue_stmt -> . CONTINUE ;
    (39) break_stmt -> . BREAK ;
    (37) return_stmt -> . RETURN expr ;
    (38) return_stmt -> . RETURN ;
    (34) while_stmt -> . WHILE ( expr ) stmt
    (35) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt
    (20) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . ;
    (33) expr_stmt -> . expr ;
    (41) expr -> . NEW type_spec [ expr ]
    (42) expr -> . STRING_LIT
    (43) expr -> . FLOAT_LIT
    (44) expr -> . INT_LIT
    (45) expr -> . BOOL_LIT
    (46) expr -> . IDENT . SIZE
    (47) expr -> . IDENT ( args )
    (48) expr -> . IDENT [ expr ]
    (49) expr -> . IDENT
    (50) expr -> . ( expr )
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ! expr
    (54) expr -> . expr % expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (59) expr -> . expr > expr
    (60) expr -> . expr GE expr
    (61) expr -> . expr < expr
    (62) expr -> . expr LE expr
    (63) expr -> . expr NE expr
    (64) expr -> . expr EQ expr
    (65) expr -> . expr AND expr
    (66) expr -> . expr OR expr
    (67) expr -> . IDENT [ expr ] = expr
    (68) expr -> . IDENT = expr
    CONTINUE        shift and go to state 7
    BREAK           shift and go to state 47
    RETURN          shift and go to state 48
    WHILE           shift and go to state 50
    IF              shift and go to state 52
    {               shift and go to state 31
    ;               shift and go to state 46
    NEW             shift and go to state 53
    STRING_LIT      shift and go to state 54
    FLOAT_LIT       shift and go to state 55
    INT_LIT         shift and go to state 56
    BOOL_LIT        shift and go to state 57
    IDENT           shift and go to state 58
    (               shift and go to state 51
    +               shift and go to state 59
    -               shift and go to state 60
    !               shift and go to state 61

    expr                           shift and go to state 49
    stmt                           shift and go to state 129
    continue_stmt                  shift and go to state 39
    break_stmt                     shift and go to state 40
    return_stmt                    shift and go to state 41
    while_stmt                     shift and go to state 42
    if_stmt                        shift and go to state 43
    compound_stmt                  shift and go to state 44
    expr_stmt                      shift and go to state 45

state 128

    (67) expr -> IDENT [ expr ] = expr .
    (54) expr -> expr . % expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (59) expr -> expr . > expr
    (60) expr -> expr . GE expr
    (61) expr -> expr . < expr
    (62) expr -> expr . LE expr
    (63) expr -> expr . NE expr
    (64) expr -> expr . EQ expr
    (65) expr -> expr . AND expr
    (66) expr -> expr . OR expr
    ;               reduce using rule 67 (expr -> IDENT [ expr ] = expr .)
    )               reduce using rule 67 (expr -> IDENT [ expr ] = expr .)
    ,               reduce using rule 67 (expr -> IDENT [ expr ] = expr .)
    ]               reduce using rule 67 (expr -> IDENT [ expr ] = expr .)
    %               shift and go to state 68
    /               shift and go to state 69
    *               shift and go to state 70
    -               shift and go to state 71
    +               shift and go to state 72
    >               shift and go to state 73
    GE              shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    NE              shift and go to state 77
    EQ              shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80


state 129

    (35) if_stmt -> IF ( expr ) stmt ELSE stmt .
    }               reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ;               reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NEW             reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING_LIT      reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_LIT       reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_LIT         reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL_LIT        reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 35 (if_stmt -> IF ( expr ) stmt ELSE stmt .)


Conflicts:

shift/reduce conflict for CONTINUE in state 31 resolved as shift
shift/reduce conflict for CONTINUE in state 36 resolved as shift